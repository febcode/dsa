Understanding Time Complexity (Big O Notation)

What is Time Complexity?

Time complexity is a way to express how the runtime of your algorithm grows as the input size increases. It helps us measure the efficiency of our code — especially when dealing with large inputs.


Why It’s Important:

In interviews, your code needs to be not just correct but also optimized. Time complexity shows whether your solution will work well as the problem size grows.


Common Time Complexities:

O(1) – Constant Time: Fastest. Example: Accessing an element in an array.

O(log n) – Logarithmic Time: Example: Binary Search in a sorted array.

O(n) – Linear Time: Example: Looping through an array.

O(n log n) – Log-linear Time: Example: Merge Sort, Quick Sort (average case).

O(n²) – Quadratic Time: Example: Nested loops like in Bubble Sort.

O(2^n) – Exponential Time: Very slow. Example: Recursive Fibonacci.


How It’s Asked in Interviews:

Interviewers might ask:

“Can you improve this solution’s time complexity?”

“What’s the Big O of your approach?”


